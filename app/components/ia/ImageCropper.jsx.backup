"use client"
import { useRef, useState, useEffect } from 'react'

export default function ImageCropper({ src, onCrop, onCancel, mode = 'factura' }) {
  const canvasRef = useRef(null)
  const imageRef = useRef(null)
  const [crop, setCrop] = useState({ x: 0, y: 0, width: 0, height: 0 })
  const [isDragging, setIsDragging] = useState(false)
  const [dragType, setDragType] = useState(null) // 'corner', 'edge', 'move', 'new', 'guide'
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
  const [dragGuideIndex, setDragGuideIndex] = useState(null)
  const [showGuides, setShowGuides] = useState(true)
  const [scale, setScale] = useState(1)
  const [guides, setGuides] = useState([])

  useEffect(() => {
    const img = new Image()
    img.src = src
    img.onload = () => {
      imageRef.current = img
      const canvas = canvasRef.current
      const ctx = canvas.getContext('2d')
      
      // Maximizar el tama√±o - usar 95% del viewport menos padding
      const maxWidth = window.innerWidth - 100
      const maxHeight = window.innerHeight - 250
      const imgScale = Math.min(maxWidth / img.width, maxHeight / img.height, 1)
      setScale(imgScale)
      
      canvas.width = img.width * imgScale
      canvas.height = img.height * imgScale
      
      // Inicializar crop con toda la imagen
      const initialCrop = { 
        x: 0, 
        y: 0, 
        width: canvas.width, 
        height: canvas.height 
      }
      setCrop(initialCrop)
      
      // Inicializar gu√≠as
      setGuides(getDefaultGuidesForMode(initialCrop))
      
      drawImage()
    }
  }, [src])

  useEffect(() => {
    drawImage()
  }, [crop, showGuides, guides])

  const drawImage = () => {
    const canvas = canvasRef.current
    const img = imageRef.current
    if (!canvas || !img) return
    
    const ctx = canvas.getContext('2d')
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    
    // Dibujar imagen
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
    
    // Overlay oscuro fuera del crop
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'
    ctx.fillRect(0, 0, canvas.width, crop.y)
    ctx.fillRect(0, crop.y, crop.x, crop.height)
    ctx.fillRect(crop.x + crop.width, crop.y, canvas.width - crop.x - crop.width, crop.height)
    ctx.fillRect(0, crop.y + crop.height, canvas.width, canvas.height - crop.y - crop.height)
    
    // Dibujar rect√°ngulo de selecci√≥n
    ctx.strokeStyle = '#3b82f6'
    ctx.lineWidth = 2
    ctx.strokeRect(crop.x, crop.y, crop.width, crop.height)
    
    // Esquinas del crop (m√°s grandes)
    const cornerSize = 16
    ctx.fillStyle = '#3b82f6'
    const corners = [
      { x: crop.x, y: crop.y },
      { x: crop.x + crop.width, y: crop.y },
      { x: crop.x, y: crop.y + crop.height },
      { x: crop.x + crop.width, y: crop.y + crop.height },
    ]
    corners.forEach(corner => {
      ctx.fillRect(corner.x - cornerSize/2, corner.y - cornerSize/2, cornerSize, cornerSize)
      // Borde blanco
      ctx.strokeStyle = 'white'
      ctx.lineWidth = 2
      ctx.strokeRect(corner.x - cornerSize/2, corner.y - cornerSize/2, cornerSize, cornerSize)
    })
    
    // Puntos en el medio de cada borde para redimensionar
    const edgeSize = 12
    ctx.fillStyle = '#3b82f6'
    const edges = [
      { x: crop.x + crop.width / 2, y: crop.y }, // top
      { x: crop.x + crop.width / 2, y: crop.y + crop.height }, // bottom
      { x: crop.x, y: crop.y + crop.height / 2 }, // left
      { x: crop.x + crop.width, y: crop.y + crop.height / 2 }, // right
    ]
    edges.forEach(edge => {
      ctx.beginPath()
      ctx.arc(edge.x, edge.y, edgeSize/2, 0, Math.PI * 2)
      ctx.fill()
      ctx.strokeStyle = 'white'
      ctx.lineWidth = 2
      ctx.stroke()
    })
    
    // Gu√≠as seg√∫n el modo
    if (showGuides) {
      drawGuides(ctx)
    }
  }

  const drawGuides = (ctx) => {
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)'
    ctx.lineWidth = 2
    ctx.setLineDash([5, 5])
    
    guides.forEach((guide, idx) => {
      if (guide.type === 'horizontal') {
        ctx.beginPath()
        ctx.moveTo(crop.x, guide.y)
        ctx.lineTo(crop.x + crop.width, guide.y)
        ctx.stroke()
      } else if (guide.type === 'vertical') {
        ctx.beginPath()
        ctx.moveTo(guide.x, crop.y)
        ctx.lineTo(guide.x, crop.y + crop.height)
        ctx.stroke()
      } else if (guide.type === 'box') {
        ctx.strokeRect(guide.x, guide.y, guide.width, guide.height)
      }
      
      // Etiqueta con handle para arrastrar
      if (guide.label) {
        ctx.setLineDash([])
        ctx.fillStyle = 'rgba(59, 130, 246, 0.95)'
        ctx.font = 'bold 14px system-ui'
        const metrics = ctx.measureText(guide.label)
        const padding = 6
        const labelWidth = metrics.width + padding * 2
        const labelHeight = 24
        
        let labelX = guide.x
        let labelY = guide.y - labelHeight - 4
        
        // Ajustar posici√≥n si se sale del crop
        if (labelY < crop.y) labelY = guide.y + 4
        if (labelX + labelWidth > crop.x + crop.width) labelX = crop.x + crop.width - labelWidth
        if (labelX < crop.x) labelX = crop.x
        
        // Fondo con cursor de arrastre
        ctx.fillRect(labelX, labelY, labelWidth, labelHeight)
        
        // Icono de arrastre
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'
        ctx.fillRect(labelX + 4, labelY + 8, 2, 8)
        ctx.fillRect(labelX + 7, labelY + 8, 2, 8)
        
        // Texto
        ctx.fillStyle = 'white'
        ctx.fillText(guide.label, labelX + padding + 8, labelY + 17)
        
        // Guardar posici√≥n del label para detecci√≥n de click
        guide.labelBounds = { x: labelX, y: labelY, width: labelWidth, height: labelHeight }
        
        ctx.moveTo(crop.x, y)
        ctx.lineTo(crop.x + crop.width, y)
        ctx.stroke()
      } else if (guide.type === 'vertical') {
        ctx.beginPath()
        ctx.moveTo(x, crop.y)
        ctx.lineTo(x, crop.y + crop.height)
        ctx.stroke()
      } else if (guide.type === 'box') {
        ctx.strokeRect(x, y, crop.width * guide.w, crop.height * guide.h)
      }
      
      // Guardar posici√≥n del label para detecci√≥n de click
      guide.labelBounds = { x: labelX, y: labelY, width: labelWidth, height: labelHeight }
      
      ctx.setLineDash([5, 5])
    })
    
    ctx.setLineDash([])
  }

  const getDefaultGuidesForMode = (cropArea) => {
    const templates = {
      factura: [
        { type: 'box', xRatio: 0.05, yRatio: 0.05, wRatio: 0.4, hRatio: 0.15, label: 'üìç Proveedor' },
        { type: 'box', xRatio: 0.55, yRatio: 0.05, wRatio: 0.4, hRatio: 0.15, label: 'üìç Fecha/Nro' },
        { type: 'horizontal', yRatio: 0.25, label: 'üì¶ Productos' },
        { type: 'box', xRatio: 0.6, yRatio: 0.85, wRatio: 0.35, hRatio: 0.1, label: 'üí∞ Total' },
      ],
      producto: [
        { type: 'box', xRatio: 0.1, yRatio: 0.1, wRatio: 0.8, hRatio: 0.3, label: 'üè∑Ô∏è Marca/Nombre' },
        { type: 'box', xRatio: 0.1, yRatio: 0.45, wRatio: 0.8, hRatio: 0.2, label: 'üìè Presentaci√≥n' },
        { type: 'box', xRatio: 0.1, yRatio: 0.7, wRatio: 0.8, hRatio: 0.15, label: 'üìä C√≥digo barras' },
      ],
      general: []
    }
    
    const template = templates[mode] || []
    
    return template.map(t => {
      const guide = { ...t }
      
      if (t.type === 'box') {
        guide.x = cropArea.x + cropArea.width * t.xRatio
        guide.y = cropArea.y + cropArea.height * t.yRatio
        guide.width = cropArea.width * t.wRatio
        guide.height = cropArea.height * t.hRatio
      } else if (t.type === 'horizontal') {
        guide.y = cropArea.y + cropArea.height * t.yRatio
      } else if (t.type === 'vertical') {
        guide.x = cropArea.x + cropArea.width * t.xRatio
      }
      
      return guide
    })
  }
          { type: 'horizontal', x: 0, y: 0.25, label: 'üì¶ Productos' },
          { type: 'box', x: 0.6, y: 0.85, w: 0.35, h: 0.1, label: 'üí∞ Total' },
        ]
      cDragStart({ x, y })
    
    // Verificar si se clicke√≥ una gu√≠a
    if (showGuides) {
      for (let i = 0; i < guides.length; i++) {
    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top
    
    // Actualizar cursor
    if (!isDragging) {
      updateCursor(x, y)
    }
    
    if (!isDragging) return
    
    const dx = x - dragStart.x
    const dy = y - dragStart.y
    
    if (dragType === 'guide') {
      // Mover gu√≠a
      const newGuides = [...guides]
      const guide = newGuides[dragGuideIndex]
      
      if (guide.type === 'box') {
        guide.x = Math.max(crop.x, Math.min(crop.x + crop.width - guide.width, guide.x + dx))
        guide.y = Math.max(crop.y, Math.min(crop.y + crop.height - guide.height, guide.y + dy))
      } else if (guide.type === 'horizontal') {
        guide.y = Math.max(crop.y, Math.min(crop.y + crop.height, guide.y + dy))
      } else if (guide.type === 'vertical') {
        guide.x = Math.max(crop.x, Math.min(crop.x + crop.width, guide.x + dx))
      }
      
      setGuides(newGuides)
      setDragStart({ x, y })
    } else if (dragType === 'move') {
      // Mover todo el crop
      const newCrop = { ...crop }
      newCrop.x = Math.max(0, Math.min(canvasRef.current.width - crop.width, crop.x + dx))
      newCrop.y = Math.max(0, Math.min(canvasRef.current.height - crop.height, crop.y + dy))
      setCrop(newCrop)
      setDragStart({ x, y })
    } else if (dragType.startsWith('corner-')) {
    setDragType(null)
    setDragGuideIndex(null)
      // Redimensionar desde esquina
      const newCrop = { ...crop }
      
      if (dragType.includes('n')) {
        const newY = Math.max(0, Math.min(y, crop.y + crop.height - 20))
        newCrop.height = crop.height + (crop.y - newY)
        newCrop.y = newY
      }
      if (dragType.includes('s')) {
        newCrop.height = Math.max(20, Math.min(canvasRef.current.height - crop.y, y - crop.y))
      }
      if (dragType.includes('w')) {
        const newX = Math.max(0, Math.min(x, crop.x + crop.width - 20))
        newCrop.width = crop.width + (crop.x - newX)
        newCrop.x = newX
      }
      if (dragType.includes('e')) {
        newCrop.width = Math.max(20, Math.min(canvasRef.current.width - crop.x, x - crop.x))
      }
      
      setCrop(newCrop)
    } else if (dragType.startsWith('edge-')) {
      // Redimensionar desde borde
      const newCrop = { ...crop }
      
      if (dragType === 'edge-top') {
        const newY = Math.max(0, Math.min(y, crop.y + crop.height - 20))
        newCrop.height = crop.height + (crop.y - newY)
        newCrop.y = newY
      } else if (dragType === 'edge-bottom') {
        newCrop.height = Math.max(20, Math.min(canvasRef.current.height - crop.y, y - crop.y))
      } else if (dragType === 'edge-left') {
    const newCrop = { 
      x: 0, 
      y: 0, 
      width: canvasRef.current.width, 
      height: canvasRef.current.height 
    }
    setCrop(newCrop)
    setGuides(getDefaultGuidesForMode(newCrop) }
      
      setCrop(newCrop)
    } else if (dragType === 'new') {
      // Nueva selecci√≥n
      const newCrop = {
        x: Math.min(dragStart.x, x),
        y: Math.min(dragStart.y, y),
        width: Math.abs(x - dragStart.x),
        height: Math.abs(y - dragStart.y),
      }
      
      newCrop.x = Math.max(0, Math.min(newCrop.x, canvasRef.current.width - newCrop.width))
      newCrop.y = Math.max(0, Math.min(newCrop.y, canvasRef.current.height - newCrop.height))
      
      setCrop(newCrop)
    }
  }
  
  const updateCursor = (x, y) => {
    const canvas = canvasRef.current
    if (!canvas) return
    
    // Verificar gu√≠as
    if (showGuides) {
      for (let guide of guides) {
        if (guide.labelBounds) {
          const lb = guide.labelBounds
          if (x >= lb.x && x <= lb.x + lb.width && y >= lb.y && y <= lb.y + lb.height) {
            canvas.style.cursor = 'move'
            return
          }
        }
      }
    }
    
    // Verificar esquinas
    const cornerHitSize = 20
    const corners = [
      { x: crop.x, y: crop.y, cursor: 'nw-resize' },
      { x: crop.x + crop.width, y: crop.y, cursor: 'ne-resize' },
      { x: crop.x, y: crop.y + crop.height, cursor: 'sw-resize' },
      { x: crop.x + crop.width, y: crop.y + crop.height, cursor: 'se-resize' },
    ]
    
    for (let corner of corners) {
      if (Math.abs(x - corner.x) <= cornerHitSize && Math.abs(y - corner.y) <= cornerHitSize) {
        canvas.style.cursor = corner.cursor
        return
      }
    }
    
    // Verificar bordes
    const edgeHitSize = 15
    if (Math.abs(x - (crop.x + crop.width / 2)) <= edgeHitSize && Math.abs(y - crop.y) <= edgeHitSize) {
      canvas.style.cursor = 'n-resize'
      return
    }
    if (Math.abs(x - (crop.x + crop.width / 2)) <= edgeHitSize && Math.abs(y - (crop.y + crop.height)) <= edgeHitSize) {
      canvas.style.cursor = 's-resize'
      return
    }
    if (Math.abs(y - (crop.y + crop.height / 2)) <= edgeHitSize && Math.abs(x - crop.x) <= edgeHitSize) {
      canvas.style.cursor = 'w-resize'
      return
    }
    if (Math.abs(y - (crop.y + crop.height / 2)) <= edgeHitSize && Math.abs(x - (crop.x + crop.width)) <= edgeHitSize) {
      canvas.style.cursor = 'e-resize'
      return90 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-2xl w-[95vw] h-[95vh] flex flex-col
    
    // Dentro del crop
    if (x >= crop.x && x <= crop.x + crop.width && y >= crop.y && y <= crop.y + crop.height) {
      canvas.style.cursor = 'move'
      return
    }
    
    canvas.style.cursor = 'crosshair'crop.width, y: crop.y, cursor: 'ne' },
      { x: crop.x, y: crop.y + crop.height, cursor: 'sw' },
      { x: crop.x + crop.width, y: crop.y + crop.height, cursor: 'se' },
    ]
    
    for (let corner of corners) {
      if (Math.abs(x - corner.x) <= cornerHitSize && Math.abs(y - corner.y) <= cornerHitSize) {
        setIsDragging(true)
        setDragType('corner-' + corner.cursor)
        return
      }
    }
    
    // Verificar bordes
    const edgeHitSize = 15
    if (Math.abs(x - (crop.x + crop.width / 2)) <= edgeHitSize && Math.abs(y - crop.y) <= edgeHitSize) {
      setIsDragging(true)
      setDragType('edge-top')
      return
    }
    if (Math.abs(x - (crop.x + crop.width / 2)) <= edgeHitSize && Math.abs(y - (crop.y + crop.height)) <= edgeHitSize) {
      setIsDragging(true)
      setDragType('edge-bottom')
      return
    }
    if (Math.abs(y - (crop.y + crop.height / 2)) <= edgeHitSize && Math.abs(x - crop.x) <= edgeHitSize) {
      setIsDragging(true)
      setDragType('edge-left')
      return
    }
    if (Math.abs(y - (crop.y + crop.height / 2)) <= edgeHitSize && Math.abs(x - (crop.x + crop.width)) <= edgeHitSize) {
      setIsDragging(true)
      setDragType('edge-right')
      return
    }
    
    // Verificar si est√° dentro del crop para moverlo
    if (x >= crop.x && x <= crop.x + crop.width && y >= crop.y && y <= crop.y + crop.height) {
      setIsDragging(true)
      setDragType('move')
      return
    }
    
    // Nueva selecci√≥n
    setIsDragging(true)
    setDragType('new'
          { type: 'box', x: 0.1, y: 0.1, w: 0.8, h: 0.3, label: 'üè∑Ô∏è Marca/Nombre' },
          { type: 'box', x: 0.1, y: 0.45, w: 0.8, h: 0.2, label: 'üìè Presentaci√≥n' },
          { type: 'box', x: 0.1, y: 0.7, w: 0.8, h: 0.15, label: 'üìä C√≥digo barras' },
        ]
      default:
        return []
    }
  }

  const handleMouseDown = (e) => {
    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top
    
    setIsDragging(true)
    setDragStart({ x, y })
  }

  const handleMouseMove = (e) => {
    if (!isDragging) return
    
    const rect = canvasRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top
    
    const newCrop = {
      x: Math.min(dragStart.x, x),
      y: Math.min(dragStart.y, y),
      width: Math.abs(x - dragStart.x),
      height: Math.abs(y - dragStart.y),
    }
    
    // Limitar a los bordes del canvas
    newCrop.x = Math.max(0, Math.min(newCrop.x, canvasRef.current.width - newCrop.width))
    newCrop.y = Math.max(0, Math.min(newCrop.y, canvasRef.current.height - newCrop.height))
    
    setCrop(newCrop)
  }

  const handleMouseUp = () => {
    setIsDragging(false)
  }

  const handleCrop = () => {
    const canvas = canvasRef.current
    const img = imageRef.current
    if (!canvas || !img) return
    
    // Crear canvas para la imagen recortada
    const cropCanvas = document.createElement('canvas')
    const cropCtx = cropCanvas.getContext('2d')
    
    // Convertir coordenadas del canvas escalado a coordenadas de imagen original
    const realX = crop.x / scale
    const realY = crop.y / scale
    const realWidth = crop.width / scale
    const realHeight = crop.height / scale
    
    cropCanvas.width = realWidth
    cropCanvas.height = realHeight
    
    cropCtx.drawImage(
      img,
      realX, realY, realWidth, realHeight,
      0, 0, realWidth, realHeight
    )
    
    // Convertir a blob
    cropCanvas.toBlob((blob) => {
      const file = new File([blob], 'cropped-image.jpg', { type: 'image/jpeg' })
      onCrop(file, URL.createObjectURL(blob))
    }, 'image/jpeg', 0.95)
  }

  const resetCrop = () => {
    setCrop({ 
      x: 0, 
      y: 0, 
      width: canvasRef.current.width, 
      height: canvasRef.current.height 
    })
  }
 flex-shrink-0">
          <div>
            <h3 className="font-semibold text-lg text-gray-900">‚úÇÔ∏è Recortar imagen</h3>
            <p className="text-sm text-gray-600">
              <span className="font-medium">üí° Controles:</span> 
              Arrastra esquinas/bordes para redimensionar ‚Ä¢ 
              Arrastra dentro para mover ‚Ä¢ 
              Arrastra etiquetas para reposicionar gu√≠as
            </p>
          </div>
          <button 
            onClick={onCancel}
            className="text-gray-500 hover:text-gray-700 text-3xl leading-none px-2"
          >
            √ó
          </button>
        </div>
        
        <div className="flex-1 overflow-auto p-4">
          <div className="mb-3 flex gap-3 items-center flex-wrap
        </div>
        
        <div className="p-4">
          <div className="mb-4 flex gap-3 items-center">
            <button
              onClick={() => setShowGuides(!showGuides)}
              className={`px-3 py-1.5 rounded-lg text-sm border transition-colors ${
                showGuides 
                  ? 'bg-blue-50 border-blue-300 text-blue-700' 
                  : 'bg-gray-50 border-gray-300 text-gray-700'
              }`}
            >
              {showGuides ? 'üëÅÔ∏è Ocultar gu√≠as' : 'üëÅÔ∏è Mostrar gu√≠as'}
            </button>
            
            <buttonsm text-gray-700 font-medium bg-gray-100 px-3 py-1.5 rounded-lg border border-gray-300">
              üìê {Math.round(crop.width / scale)} √ó {Math.round(crop.height / scale)} px
            </div>
          </div>
          
          <div className="bg-gray-900 rounded-lg flex justify-center items-center min-h-0" style={{ height: 'calc(100% - 60px)' }}>
            <canvas
              ref={canvasRef}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
              className="max-w-full max-h-full"
              style={{ touchAction: 'none' }}
            />
          </div>
        </div>
        
        <div className="p-4 border-t border-gray-200 flex gap-3 justify-end flex-shrink-0
              className="cursor-crosshair max-w-full"
              style={{ touchAction: 'none' }}
            />
          </div>
        </div>
        
        <div className="p-4 border-t border-gray-200 flex gap-3 justify-end">
          <button
            onClick={onCancel}
            className="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50"
          >
            Cancelar
          </button>
          <button
            onClick={handleCrop}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            ‚úÇÔ∏è Aplicar recorte
          </button>
        </div>
      </div>
    </div>
  )
}
